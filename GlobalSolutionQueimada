from os import system
import random
import os
import json
import time
import requests 
from datetime import datetime
from threading import Thread


global login_status
login_status = False  # VariÃ¡vel global para controlar o status de login


def carregar_dados(arquivo: json) -> dict:
    '''
    Carrega os dados de um arquivo JSON e retorna um dicionÃ¡rio.
    Complexidade: O(n)
    '''
    if os.path.exists(arquivo):
        with open(arquivo, 'r', encoding='utf-8') as file:
            try:
                conteudo = file.read().strip()
                if not conteudo:
                    return {}  # Arquivo estÃ¡ vazio
                return json.loads(conteudo)
            except json.JSONDecodeError:
                print(f"Erro ao ler o arquivo {arquivo}. Formato invÃ¡lido.")
                return {}
    return {}


def salvar_dados(dados: dict, arquivo: json) -> None:
    '''
    Salva os dados em um arquivo JSON.
    Complexidade: O(n)
    '''
    with open(arquivo, 'w', encoding='utf-8') as file:
        json.dump(dados, file, indent=4)

def usuario_id(dados: dict) -> str:
    '''
    Gera um ID Ãºnico para o usuÃ¡rio.
    Complexidade: O(n)
    '''
    id_usuario = str(random.randint(1000, 9999))
    while id_usuario in dados:
        id_usuario = str(random.randint(1000, 9999))
    return id_usuario


def cadastro_usuario() -> None:
    '''
    Cadastro de usuÃ¡rio com nome e senha.
    Complexidade: O(1) para inserÃ§Ã£o + O(n) para verificaÃ§Ã£o opcional de duplicata
    Retorno: None
    '''
    global login_status
    print("Cadastro de UsuÃ¡rio")
    if not login_status:
        nome = input("Digite o nome do usuÃ¡rio: ").strip().title()

        while True:
            senha = input("Digite a senha do usuÃ¡rio (mÃ­nimo 8 caracteres): ")
            if len(senha) < 8:
                print("A senha deve ter pelo menos 8 caracteres.")
            else:
                break


        usuarios = carregar_dados('usuarios.json')
        

        # Verifica se o nome de usuÃ¡rio jÃ¡ existe
        for user in usuarios.values():
            if user['nome'] == nome:
                print("UsuÃ¡rio jÃ¡ existe. Escolha outro nome.")
                return

        id_usuario = usuario_id(usuarios)
        usuarios[id_usuario] = {
            'nome': nome,
            'senha': senha
        }
        salvar_dados(usuarios, 'usuarios.json')
        login_status = True
        print(f"UsuÃ¡rio {nome} cadastrado com sucesso!")
    else:
        print("VocÃª jÃ¡ estÃ¡ logado. Reinicie o programa para cadastrar outro usuÃ¡rio.")


def login_usuario() -> None:
    '''
    Login de usuÃ¡rio validando nome e senha.
    Complexidade: O(n)
    '''
    global login_status
    print("Login de UsuÃ¡rio")
    if not login_status:
        nome = input("Digite o nome do usuÃ¡rio: ").strip().title()
        senha = input("Digite a senha do usuÃ¡rio: ")

        usuarios = carregar_dados('usuarios.json')
        if not usuarios:
            print("Nenhum usuÃ¡rio cadastrado ainda.")
            return

        for usuario in usuarios.values():
            if usuario['nome'] == nome and usuario['senha'] == senha:
                print(f"Login realizado com sucesso! Bem-vindo, {nome}.")
                login_status = True
                return

        print("Nome de usuÃ¡rio ou senha incorretos.")
    else:
        print("VocÃª jÃ¡ estÃ¡ logado.")


def ocorrencia_aleatoria() -> None:
    '''
    Gera uma ocorrÃªncia aleatÃ³ria baseada na API do IBGE.
    Complexidade: O(n)
    '''
    try:
        response = requests.get("https://servicodados.ibge.gov.br/api/v1/localidades/municipios")
        if response.status_code == 200:
            municipios = response.json()
            cidade_aleatoria = random.choice(municipios)
            nome_cidade = cidade_aleatoria['nome']
            uf = cidade_aleatoria['microrregiao']['mesorregiao']['UF']['sigla']
            local = f"{nome_cidade}/{uf}"
            
            data = datetime.now().strftime("%d/%m/%Y")
            nivel_de_perigo = random.randint(1, 5)
            
            nova_ocorrencia = {
                'local': local,
                'data': data,
                'nivel_de_perigo': nivel_de_perigo
            }

            notificacoes = carregar_dados('notificacoes.json')
            ocorrencias = carregar_dados('ocorrencias.json')
            id_ocorrencia = str(random.randint(1000, 9999))
            while id_ocorrencia in notificacoes:
                id_ocorrencia = str(random.randint(1000, 9999))
            if nivel_de_perigo >= 4:
                notificacoes[id_ocorrencia] = nova_ocorrencia
            ocorrencias[id_ocorrencia] = nova_ocorrencia
            salvar_dados(ocorrencias, 'ocorrencias.json')
            salvar_dados(notificacoes, 'notificacoes.json')
    except Exception as e:
        print(f"Erro ao gerar ocorrÃªncia: {e}")


def loop_ocorrencia_aleatoria() -> None:
    '''
    Loop que gera ocorrÃªncias aleatÃ³rias a cada 3 segundos.
    '''
    while True:
        ocorrencia_aleatoria()
        time.sleep(3)


def cadastrar_ocorrencia() -> None:
    '''
    Cadastro manual de ocorrÃªncia.
    Complexidade: O(n)
    '''
    print("Cadastro de OcorrÃªncia")
    if  login_status:
        local = input("Digite o local da ocorrÃªncia: ").strip().title()
        data = datetime.now().strftime("%d/%m/%Y")
        nivel_de_perigo = random.randint(1, 5)
        
        ocorrencias = carregar_dados('ocorrencias.json')
        nova_ocorrencia = {
            'local': local,
            'data': data,
            'nivel_de_perigo': nivel_de_perigo
        }
        ocorrencias[str(random.randint(1000, 9999))] = nova_ocorrencia
        salvar_dados(ocorrencias, 'ocorrencias.json')
        print(f"OcorrÃªncia cadastrada com sucesso no local {local} com nÃ­vel {nivel_de_perigo}.")
    else:
        print("VocÃª nÃ£o estÃ¡ logado.")


def checar_ocorrencias(arquivo: json) -> None:
    '''
    Exibe todas as ocorrÃªncias salvas.
    Complexidade: O(n)
    '''
    print("VerificaÃ§Ã£o de OcorrÃªncias")
    ocorrencias = carregar_dados(arquivo)
    if not ocorrencias:
        print("Nenhuma ocorrÃªncia cadastrada.")
    else:
        for id, ocorrencia in ocorrencias.items():
            print('-' * 30)
            print(f"ID: {id}")
            print(f"Local: {ocorrencia['local']}")
            print(f"Data: {ocorrencia['data']}")
            print(f"NÃ­vel de Perigo: {ocorrencia['nivel_de_perigo']}")
            print('-' * 30)
    
    # Se for o arquivo de notificaÃ§Ãµes, limpamos apÃ³s exibiÃ§Ã£o
    if arquivo == 'notificacoes.json':
        salvar_dados({}, 'notificacoes.json')
        print("\nâœ… Todas as notificaÃ§Ãµes foram limpas apÃ³s a visualizaÃ§Ã£o.")   

    input("Pressione Enter para voltar ao menu...") #Em vez de time.sleep, usamos input para esperar o usuÃ¡rio ler as ocorrÃªncias no seu tempo


def busca_binaria(ocorrencias: list, nivel_alvo: int) -> int:
    '''
    Busca binÃ¡ria por nÃ­vel de perigo.
    Complexidade: O(log n)
    '''
    esquerda = 0
    direita = len(ocorrencias) - 1

    while esquerda <= direita:
        meio = (esquerda + direita) // 2
        _, dados = ocorrencias[meio]
        nivel = dados['nivel_de_perigo']
        
        if nivel == nivel_alvo:
            return meio
        elif nivel < nivel_alvo:
            esquerda = meio + 1
        else:
            direita = meio - 1
    return -1


def notificacao_usuario() -> None:
    '''
    Notifica usuÃ¡rio sobre ocorrÃªncias de nÃ­veis mÃ¡ximo.
    Complexidade: O(n log n)
    '''
    limpar_tela()
    ocorrencias = carregar_dados('notificacoes.json')
    if not ocorrencias:
        return

    ocorrencias_ordenadas = sorted(
        ocorrencias.items(), 
        key=lambda item: item[1]['nivel_de_perigo']
    )

    index = busca_binaria(ocorrencias_ordenadas, 5)

    if index != -1:
        chave, ocorrencia = ocorrencias_ordenadas[index]
        print(f"\n[ALERTA MÃXIMO] OcorrÃªncia perigosa detectada!")
        print(f"Local: {ocorrencia['local']}")
        print(f"Data: {ocorrencia['data']}")
        print(f"NÃ­vel de Perigo: {ocorrencia['nivel_de_perigo']}\n")

        ocorrencias.pop(chave)
        salvar_dados(ocorrencias, 'notificacoes.json')
        time.sleep(5)  # Pausa para visualizaÃ§Ã£o da notificaÃ§Ã£o
        limpar_tela()

def mostrar_sobre_sistema():
    texto = """
    Sobre o Sistema:

    Este aplicativo foi desenvolvido por trÃªs colaboradores: Fernando Carlos, Pedro Henrique Silva Batista e Juan Fuentes Rufino.

    O objetivo principal do sistema Ã© propor uma soluÃ§Ã£o tecnolÃ³gica frente ao crescente aumento dos focos de queimada sem causas aparentes. 
    ApÃ³s extensas anÃ¡lises de dados globais relacionados a incÃªndios florestais â€” com base em um conjunto de dados robusto contendo mais de um milhÃ£o de amostras â€” 
    foi possÃ­vel identificar dois pontos crÃ­ticos:

    1. Um aumento expressivo nas queimadas provocadas por aÃ§Ã£o humana, porÃ©m sem justificativa clara;
    2. Os impactos diretos dessas ocorrÃªncias nÃ£o apenas sobre o meio ambiente, mas tambÃ©m sobre a saÃºde da populaÃ§Ã£o.

    Diante desse cenÃ¡rio, desenvolvemos um aplicativo que visa integrar e proteger as comunidades que vivem prÃ³ximas a regiÃµes afetadas. 
    Entre suas principais funcionalidades, destacam-se:

    - NotificaÃ§Ã£o em tempo real de Ã¡reas com risco iminente de incÃªndio;
    - Uma aba social para que usuÃ¡rios possam registrar ou consultar ocorrÃªncias;
    - Acesso a todas as notificaÃ§Ãµes e registros pÃºblicos feitos pela comunidade.

    AlÃ©m disso, os dados inseridos pelos prÃ³prios usuÃ¡rios auxiliam no aprimoramento dos sensores, enriquecem a base de dados e fortalecem a 
    aplicaÃ§Ã£o de modelos preditivos. Dessa forma, o sistema contribui significativamente tanto para a prevenÃ§Ã£o de desastres quanto para a preservaÃ§Ã£o ambiental e o bem-estar coletivo.
    """
    print(texto)


def limpar_tela() -> None:
    '''
    Limpa a tela do terminal.
    '''
    os.system('cls' if os.name == 'nt' else 'clear')


def menu() -> None:
    '''
    Menu principal do sistema com interface mais amigÃ¡vel.
    '''
    global login_status
    while True:
        time.sleep(2) # Pausa para visualizaÃ§Ã£o da tela anterior
        if login_status:
            notificacao_usuario()       
        limpar_tela()
        print("="*50)
        print("        ğŸ›¡ï¸  SISTEMA DE OCORRÃŠNCIAS AO VIVO ğŸ›¡ï¸")
        print("="*50)
        print("Bem-vindo! Escolha uma das opÃ§Ãµes abaixo:\n")
        print("1. ğŸ‘¤ Cadastrar UsuÃ¡rio")
        print("   â¤ Crie um novo usuÃ¡rio para acessar o sistema.\n")
        print("2. ğŸ” Login de UsuÃ¡rio")
        print("   â¤ Acesse sua conta com nome e senha.\n")
        print("3. ğŸ“ Cadastrar OcorrÃªncia")
        print("   â¤ Registre manualmente uma nova ocorrÃªncia.\n")
        print("4. ğŸ“‚ Verificar OcorrÃªncias")
        print("   â¤ Veja todas as ocorrÃªncias registradas.\n")
        print("5. ğŸš¨ NotificaÃ§Ãµes de Perigo")
        print("   â¤ Consulte apenas as ocorrÃªncias perigosas (nÃ­vel 4 ou 5).\n")
        print("6. â„¹ï¸ Para saber mais sobre o app")
        print("   â¤ InformaÃ§Ãµes sobre o sistema e seus objetivos.\n")
        print("7. âŒ Sair do Sistema")
        print("   â¤ Finaliza a execuÃ§Ã£o do programa.\n")
        print("-"*50)
        
        escolha = input("Digite o nÃºmero da opÃ§Ã£o desejada: ").strip()
        print()  # EspaÃ§o visual

        match escolha:
            case '1':
                cadastro_usuario()
            case '2':
                login_usuario()
            case '3':
                cadastrar_ocorrencia()
            case '4':
                if login_status:
                    checar_ocorrencias('ocorrencias.json')
                else:
                    print("VocÃª precisa estar logado para verificar ocorrÃªncias.")
            case '5':
                if login_status:
                    checar_ocorrencias('notificacoes.json')
                else:
                    print("VocÃª precisa estar logado para verificar notificaÃ§Ãµes.")
            case '6':
                print("penis")
            case '7':
                print("Encerrando o sistema... AtÃ© logo!")
                break
            case _:
                print("âš ï¸ OpÃ§Ã£o invÃ¡lida. Tente novamente.")
                time.sleep(2)



if __name__ == "__main__":
    # Inicia thread para gerar ocorrÃªncias em tempo real
    thread = Thread(target=loop_ocorrencia_aleatoria, daemon=True)
    thread.start()

    # Inicia o menu
    menu()
